%% Interpolation in 1D/2D/3D domains using CSRBFs combined with
%%Jacobi polynomials. 


%% Spatial dimension
dim = 1;

%% Load up the node set
if dim==1
    N = 2.^(2:8); N = N';
    for k=1:length(N)
        X = chebspace2(-1,1,N(k));
        xi = X(2:end-1,:);
        xb = [X(1,:); X(end,:)];
        st.fullintnodes{k,1} = xi;
        st.bdrynodes{k,1} = xb;
    end
    clear N xb xi k;
    xe = linspace(-1,1,2^14).';    
elseif dim==2
    %% Get evaluation nodes
    st = load('DiskPoissonNodesLarge.mat');
    xe =  [st.fullintnodes{7}; st.bdrynodes{7}];
    clear p N pxe;
elseif dim==3
     st = load('SpherePoissonNodesLarge.mat');
     xe = [st.fullintnodes{2}; st.bdrynodes{2}]; 
     st = load('SpherePoissonNodesClustered.mat');
else
  error('Unsupported dim');
end

start_nodes = 1;
end_nodes = size(st.fullintnodes,1);

% Sparsity storage initialization 
sparsity_fs1 = zeros(end_nodes, 3);
sparsity_fs2 = zeros(end_nodes, 3);
sparsity_fs3 = zeros(end_nodes, 3);
sparsity_vs1 = zeros(end_nodes, 3);
sparsity_vs2 = zeros(end_nodes, 3);
sparsity_vs3 = zeros(end_nodes, 3);

%% This partially determines the number of polynomial terms
%slightly smaller fac helps with increasing accuracy for both rough and
%smooth functions. There seems to be a notion of the "best" polynomial
%degree for a given number of nodes
if dim==1
    fac = 1;
elseif dim==2
    fac = 0.8; 
elseif dim==3
    fac = 1.0;
end

%% Setup anonymous function for function interpolation true solution
%%We'll use Trefethen's function gallery from his Spectral methods book
%%with 2d and 3d analogues
if dim==1
  tests = { ...
    struct('name','abs1d',      'fun', @(x) abs(x)), ...
    struct('name','gauss1d',    'fun', @(x) exp(-x.^(-2))), ...
    struct('name','rational1d', 'fun', @(x) 1./(1 + 16*x.^2)), ...
    struct('name','poly10_1d',  'fun', @(x) x.^10) ...
  };
  
elseif dim==2
  tests = { ...
    struct('name','abs3x3_2d',   'fun', @(x,y) abs(x).^3 .* abs(y).^3), ...
    struct('name','gauss_inv2d', 'fun', @(x,y) exp(-10*((x-.3).^(-2)+y.^(-2)))), ...
    struct('name','rational2d',  'fun', @(x,y) 1./(1 + 25*(x.^2 + y.^2))), ...
    struct('name','poly8x8_2d',  'fun', @(x,y) x.^8 .* y.^8) ...
  };

elseif dim==3
  tests = { ...
    struct('name','abs333_3d',   'fun', @(x,y,z) abs(x).^3 .* abs(y).^3 .* abs(z).^3), ...
    struct('name','gauss3d',     'fun', @(x,y,z) exp(-10*((x-.3).^2+y.^2+z.^2))), ...
    struct('name','rational3d',  'fun', @(x,y,z) 1./(1 + 16*(x.^2 + y.^2 + z.^2))), ...
    struct('name','poly422_3d',  'fun', @(x,y,z) x.^4 .* y.^2 .* z.^2) ...
  };

else
  error('Unsupported dimension %d', dim);
end

f = matlabFunction(f);
if dim==1
    dfx = matlabFunction(dfx);
    clear x;
elseif dim==2
    dfx = matlabFunction(dfx);
    dfy = matlabFunction(dfy);
    clear x y;
elseif dim==3
    dfx = matlabFunction(dfx);
    dfy = matlabFunction(dfy);
    dfz = matlabFunction(dfz);
    clear x y z;
end
%% All possible tests:
%% 1. Different smoothness for CSRBF
%% 2. Different shape parameter strats
%% 3. Different interp techniques

for ti = 1:numel(tests)
    testName = tests{ti}.name;
    ffun     = tests{ti}.fun;
    
    % recreate your per-test results folder …
    results_dir = fullfile('CleanLagrangeApprox','results',sprintf('%s_dim%d',testName,dim));
    if ~exist(results_dir,'dir'), mkdir(results_dir); end

  %% PLS baseline
    for k = start_nodes:end_nodes
        xi = st.fullintnodes{k};
        xb = st.bdrynodes   {k};
        x  = [xi; xb];
        ell = max(1,floor(fac*nthroot(size(x,1),dim)));
        
        % evaluate at collocation points
        if dim==1
          y       = ffun(x(:,1));
          ye_true = ffun(xe(:,1));
        elseif dim==2
          y       = ffun(x(:,1), x(:,2));
          ye_true = ffun(xe(:,1),xe(:,2));
        else  % dim==3
          y       = ffun(x(:,1),x(:,2),x(:,3));
          ye_true = ffun(xe(:,1),xe(:,2),xe(:,3));
        end
        
        [ el2_poly(k,1),   elinf_poly(k,1), ...
          a_time_poly(k,1),e_time_poly(k,1), ...
          c_poly{k,1} ] = PLS(x,y,ell,xe,0,ye_true);
        
        sN(k,1) = nthroot(size(x,1),dim);
    end

    for smoothness=1:3
        if smoothness==1
            %% Wendland C2 in 3d, pd in all lower dimensions
            rbf = @(e,r) -r.^4.*(4.*r - 5*spones(r));
            drbfor = @(e,r) 20.*e.^2.*r.^3;
            if dim==1
                lrbf = @(e,r) -20.*e.^2.*r.^2.*(2.*r - 3*spones(r));
            elseif dim==2
                lrbf = @(e,r) -20.*e.^2.*r.^2.*(r - 3*spones(r));
            elseif dim==3
                lrbf = @(e,r) 60.*e.^2.*r.^2;
            end
        elseif smoothness==2
            %% Wendland C4 in 3d
            rbf = @(e,r) (r.^6.*(35.*r.^2 - 88.*r + 56*spones(r)))./3;
            drbfor = @(e,r) -(56.*e.^2.*r.^5.*(5.*r - 6*spones(r)))./3;
            if dim==2
                lrbf = @(e,r) (112.*e.^2.*r.^4.*(20.*r.^2 - 36.*r + 15*spones(r)))./3;   
            elseif dim==3    
                lrbf = @(e,r) 56.*e.^2.*r.^4.*(15.*r.^2 - 26.*r + 10*spones(r));
            end
        elseif smoothness==3
            %% Wendland C6 in 3d
            rbf = @(e,r) r.^8.*(66*spones(r) - 154*r + 121*r.^2 - 32*r.^3);
            drbfor = @(e,r) 22.*e.^2.*r.^7.*(16.*r.^2 - 39.*r + 24*spones(r));
            if dim==2
                lrbf = @(e,r) 44*e.^2.*r.^6.*(84*spones(r)-264*r+267*r.^2-88*r.^3);
            elseif dim==3
                lrbf = @(e,r) -66.*e.^2.*r.^6.*((r - spones(r)).^2 - 6.*r + 64.*(r - spones(r)).^3 + 7*spones(r));
            end
        else
            %% Wendland C8 in 3d
            rbf = @(e,r) (6552290047271679.*r.^10.*(4134.*r.^2 - 3536.*r - 2166.*r.^3 + 429.*r.^4 + 1144*spones(r)))./32761450236358396;
            drbfor = @(e,r) -(85179770614531827.*e.^2.*r.^9.*(1056.*r - 852.*r.^2 + 231.*r.^3 - 440*spones(r)))./16380725118179198;
            if dim==2
                lrbf = @(e,r) (85179770614531827.*e.^2.*r.^8.*(11022.*r.^2 - 7700.*r - 6924.*r.^3 + 1617.*r.^4 + 1980*spones(r)))./8190362559089599;
            elseif dim==3
                lrbf = @(e,r) (1277696559217977405.*e.^2.*r.^8.*(1540.*r.^2 - 1056.*r - 980.*r.^3 + 231.*r.^4 + 264*spones(r)))./16380725118179198;
            end
        end
    
        for k = start_nodes:end_nodes
          x = [ st.fullintnodes{k} ; st.bdrynodes{k} ];
          if dim==1
            y       = ffun(x(:,1));
            ye_true = ffun(xe(:,1));
          elseif dim==2
            y       = ffun(x(:,1), x(:,2));
            ye_true = ffun(xe(:,1),xe(:,2));
          else
            y       = ffun(x(:,1),x(:,2),x(:,3));
            ye_true = ffun(xe(:,1),xe(:,2),xe(:,3));
          end
          tree = KDTreeSearcher(x);
          [el2_diag(k,smoothness),elinf_diag(k,smoothness), ...
           a_time_diag(k,smoothness),e_time_diag(k,smoothness), ...
           c_poly_diag{k,smoothness}] = ...
             CSRBFDiag(x,y,ell,xe,0,rbf,tree,ye_true);
        end
    end

    for smoothness=1:3
        if smoothness==1
            %% Wendland C2 in 3d, pd in all lower dimensions
            rbf = @(e,r) -r.^4.*(4.*r - 5*spones(r));
            drbfor = @(e,r) 20.*e.^2.*r.^3;
            if dim==1
                lrbf = @(e,r) -20.*e.^2.*r.^2.*(2.*r - 3*spones(r));
            elseif dim==2
                lrbf = @(e,r) -20.*e.^2.*r.^2.*(r - 3*spones(r));
            elseif dim==3
                lrbf = @(e,r) 60.*e.^2.*r.^2;
            end
        elseif smoothness==2
            %% Wendland C4 in 3d
            rbf = @(e,r) (r.^6.*(35.*r.^2 - 88.*r + 56*spones(r)))./3;
            drbfor = @(e,r) -(56.*e.^2.*r.^5.*(5.*r - 6*spones(r)))./3;
            if dim==2
                lrbf = @(e,r) (112.*e.^2.*r.^4.*(20.*r.^2 - 36.*r + 15*spones(r)))./3;   
            elseif dim==3    
                lrbf = @(e,r) 56.*e.^2.*r.^4.*(15.*r.^2 - 26.*r + 10*spones(r));
            end
        elseif smoothness==3
            %% Wendland C6 in 3d
            rbf = @(e,r) r.^8.*(66*spones(r) - 154*r + 121*r.^2 - 32*r.^3);
            drbfor = @(e,r) 22.*e.^2.*r.^7.*(16.*r.^2 - 39.*r + 24*spones(r));
            if dim==2
                lrbf = @(e,r) 44*e.^2.*r.^6.*(84*spones(r)-264*r+267*r.^2-88*r.^3);
            elseif dim==3
                lrbf = @(e,r) -66.*e.^2.*r.^6.*((r - spones(r)).^2 - 6.*r + 64.*(r - spones(r)).^3 + 7*spones(r));
            end
        else
            %% Wendland C8 in 3d
            rbf = @(e,r) (6552290047271679.*r.^10.*(4134.*r.^2 - 3536.*r - 2166.*r.^3 + 429.*r.^4 + 1144*spones(r)))./32761450236358396;
            drbfor = @(e,r) -(85179770614531827.*e.^2.*r.^9.*(1056.*r - 852.*r.^2 + 231.*r.^3 - 440*spones(r)))./16380725118179198;
            if dim==2
                lrbf = @(e,r) (85179770614531827.*e.^2.*r.^8.*(11022.*r.^2 - 7700.*r - 6924.*r.^3 + 1617.*r.^4 + 1980*spones(r)))./8190362559089599;
            elseif dim==3
                lrbf = @(e,r) (1277696559217977405.*e.^2.*r.^8.*(1540.*r.^2 - 1056.*r - 980.*r.^3 + 231.*r.^4 + 264*spones(r)))./16380725118179198;
            end
        end
    
        for k = start_nodes:end_nodes
            % build the collocation set
            x  = [ st.fullintnodes{k};  st.bdrynodes{k} ];
            ell = max(1,floor(fac*nthroot(size(x,1),dim)));
            
            % evaluate y and true values via the anonymous ffun
            if dim==1
                y = ffun(x(:,1));
                ye_true = ffun(xe(:,1));
            elseif dim==2
                y = ffun(x(:,1),x(:,2));
                ye_true = ffun(xe(:,1),xe(:,2));
            else
                y = ffun(x(:,1),x(:,2),x(:,3));
                ye_true = ffun(xe(:,1),xe(:,2),xe(:,3));
            end
            
            % build the KD-tree and get separation radius
            tree = KDTreeSearcher(x);
            [~,d2] = knnsearch(tree,x,'k',2);
            sepR = 0.5*min(d2(:,2));
            
            % on first k, pick your three fixed-ep = [3,2.5,2]/sepR
            if k==start_nodes
                eps_fixed = [3,2.5,2] / sepR;
            end
            
            % FS1
            [ el2_fs1(k,smoothness), elinf_fs1(k,smoothness), ...
            a_time_fs1(k,smoothness), e_time_fs1(k,smoothness), ...
            ~,~, sparsity_fs1(k,smoothness) ] = ...
              CSRBFGen(x,y,ell,xe,0,rbf, eps_fixed(1), tree, ye_true);
            
            % FS2
            [ el2_fs2(k,smoothness), elinf_fs2(k,smoothness), ...
            a_time_fs2(k,smoothness), e_time_fs2(k,smoothness), ...
            ~,~, sparsity_fs2(k,smoothness) ] = ...
              CSRBFGen(x,y,ell,xe,0,rbf, eps_fixed(2), tree, ye_true);
            
            % FS3
            [ el2_fs3(k,smoothness), elinf_fs3(k,smoothness), ...
            a_time_fs3(k,smoothness), e_time_fs3(k,smoothness), ...
            ~,~, sparsity_fs3(k,smoothness) ] = ...
              CSRBFGen(x,y,ell,xe,0,rbf, eps_fixed(3), tree, ye_true);
        end
    end

    s_targets = [0.30, 0.10, 0.02];  
    tolS = 1e-5;                        % your tight tolerance
    for smoothness=1:3
        if smoothness==1
            %% Wendland C2 in 3d, pd in all lower dimensions
            rbf = @(e,r) -r.^4.*(4.*r - 5*spones(r));
            drbfor = @(e,r) 20.*e.^2.*r.^3;
            if dim==1
                lrbf = @(e,r) -20.*e.^2.*r.^2.*(2.*r - 3*spones(r));
            elseif dim==2
                lrbf = @(e,r) -20.*e.^2.*r.^2.*(r - 3*spones(r));
            elseif dim==3
                lrbf = @(e,r) 60.*e.^2.*r.^2;
            end
        elseif smoothness==2
            %% Wendland C4 in 3d
            rbf = @(e,r) (r.^6.*(35.*r.^2 - 88.*r + 56*spones(r)))./3;
            drbfor = @(e,r) -(56.*e.^2.*r.^5.*(5.*r - 6*spones(r)))./3;
            if dim==2
                lrbf = @(e,r) (112.*e.^2.*r.^4.*(20.*r.^2 - 36.*r + 15*spones(r)))./3;   
            elseif dim==3    
                lrbf = @(e,r) 56.*e.^2.*r.^4.*(15.*r.^2 - 26.*r + 10*spones(r));
            end
        elseif smoothness==3
            %% Wendland C6 in 3d
            rbf = @(e,r) r.^8.*(66*spones(r) - 154*r + 121*r.^2 - 32*r.^3);
            drbfor = @(e,r) 22.*e.^2.*r.^7.*(16.*r.^2 - 39.*r + 24*spones(r));
            if dim==2
                lrbf = @(e,r) 44*e.^2.*r.^6.*(84*spones(r)-264*r+267*r.^2-88*r.^3);
            elseif dim==3
                lrbf = @(e,r) -66.*e.^2.*r.^6.*((r - spones(r)).^2 - 6.*r + 64.*(r - spones(r)).^3 + 7*spones(r));
            end
        else
            %% Wendland C8 in 3d
            rbf = @(e,r) (6552290047271679.*r.^10.*(4134.*r.^2 - 3536.*r - 2166.*r.^3 + 429.*r.^4 + 1144*spones(r)))./32761450236358396;
            drbfor = @(e,r) -(85179770614531827.*e.^2.*r.^9.*(1056.*r - 852.*r.^2 + 231.*r.^3 - 440*spones(r)))./16380725118179198;
            if dim==2
                lrbf = @(e,r) (85179770614531827.*e.^2.*r.^8.*(11022.*r.^2 - 7700.*r - 6924.*r.^3 + 1617.*r.^4 + 1980*spones(r)))./8190362559089599;
            elseif dim==3
                lrbf = @(e,r) (1277696559217977405.*e.^2.*r.^8.*(1540.*r.^2 - 1056.*r - 980.*r.^3 + 231.*r.^4 + 264*spones(r)))./16380725118179198;
            end
        end
    
        for k=start_nodes:end_nodes
            xi = st.fullintnodes{k};
            xb = st.bdrynodes{k};
            x = [xi;xb];
    
            Nnodes = size(x,1);
    
            alph = 0; %legendre
            ell = floor(fac*nthroot(length(x),dim));            
            ell = max([ell,1]); 
            if dim==1
                y = f(x(:,1));
                ye_true = f(xe(:,1));
            elseif dim==2
                y = f(x(:,1),x(:,2));
                ye_true = f(xe(:,1),xe(:,2));
            elseif dim==3
                y = f(x(:,1),x(:,2),x(:,3));
                ye_true = f(xe(:,1),xe(:,2),xe(:,3));
            end    
            tree = KDTreeSearcher(x);
            [~,dist] = knnsearch(tree,x,'k',2);
            dist = dist(:,2);
            dist = 0.5*min(dist); %separation radius (smallest neighbor spacing (q))
            diam = norm(max(x)-min(x));  % largest inter‐point span (w)
    
            tolS = 1e-5;   % tolerance on sparsity
            ep1 = findEpForSparsity(x, tree, rbf, s_targets(1), tolS, diam);
            [el2_vs1(k,smoothness),elinf_vs1(k,smoothness),a_time_vs1(k,smoothness),e_time_vs1(k,smoothness),c_poly_vs1{k,smoothness}, ~, sparsity_vs1(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep1,tree,ye_true);
    
            ep2 = findEpForSparsity(x, tree, rbf, s_targets(2), tolS, diam);
            [el2_vs2(k,smoothness),elinf_vs2(k,smoothness),a_time_vs2(k,smoothness),e_time_vs2(k,smoothness),c_poly_vs2{k,smoothness}, ~, sparsity_vs2(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep2,tree,ye_true);
    
            ep3 = findEpForSparsity(x, tree, rbf, s_targets(3), tolS, diam);       
            [el2_vs3(k,smoothness),elinf_vs3(k,smoothness),a_time_vs3(k,smoothness),e_time_vs3(k,smoothness),c_poly_vs3{k,smoothness}, ~, sparsity_vs3(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep3,tree,ye_true); 
        end
    end
end

%% Bisection for sparsity
function ep = findEpForSparsity(x, tree, rbf, target, tol, sepR)
% findEpForSparsity  binary‐searches for ep=1/r so that nnz(A)/numel(A) ≈ target
%
% Inputs:
%   x      : N×d array of node coordinates
%   tree   : KDTreeSearcher built on x
%   rbf    : function handle @(ep,distances)->RBF values
%   target : desired fraction of nonzero A‐entries (0<target<1)
%   tol    : allowable error in achieved sparsity (e.g. 1e-3)
%   sepR   : maximum search radius (the separation radius)
%
% Output:
%   ep     : shape parameter (1/r_mid) that yields sparsity ≈ target

if nargin<5, tol = 1e-16; end
if nargin<6
    error('You must pass sepR (the separation radius) as the 6th argument.');
end

N = size(x,1);

% clamp your search range to [0, sepR]
r_low  = 0;
r_high = sepR;

for iter = 1:20
  r_mid = 0.5*(r_low + r_high);
  % count nnz entries: how many neighbors within r_mid (including self)
  neigh    = rangesearch(tree, x, r_mid);
  total_nz = sum(cellfun(@numel, neigh));  
  spars    = total_nz / (N^2);

  if abs(spars - target) < tol
    break;
  elseif spars > target
    r_high = r_mid;
  else
    r_low  = r_mid;
  end
end

ep = 1 / r_mid;
end

%% Save all results
% Build a .mat filename per test
savefile = fullfile(results_dir, sprintf('%s_dim%d_results.mat', testName, dim));
save(savefile, ...
     'el2_poly','elinf_poly','a_time_poly','e_time_poly','c_poly', ...
     'el2_diag','elinf_diag','a_time_diag','e_time_diag','c_poly_diag', ...
     'el2_fs1','elinf_fs1','a_time_fs1','e_time_fs1','sparsity_fs1', ...
     'el2_fs2','elinf_fs2','a_time_fs2','e_time_fs2','sparsity_fs2', ...
     'el2_fs3','elinf_fs3','a_time_fs3','e_time_fs3','sparsity_fs3', ...
     'el2_vs1','elinf_vs1','a_time_vs1','e_time_vs1','sparsity_vs1', ...
     'el2_vs2','elinf_vs2','a_time_vs2','e_time_vs2','sparsity_vs2', ...
     'el2_vs3','elinf_vs3','a_time_vs3','e_time_vs3','sparsity_vs3', ...
     'sN','tests','testName','dim');

%% Plotting
% 1) Error vs N^{1/d}
h = figure; hold on; grid on;
markers = {'-o','-s','-^','--o','--s','--^','-.x','-.+','-.*'};
loglog(sN, el2_poly,   markers{1}, 'LineWidth',1.2);
loglog(sN, el2_diag(:,1), markers{2}, 'LineWidth',1.2);
loglog(sN, el2_fs1(:,1),  markers{3}, 'LineWidth',1.2);
loglog(sN, el2_fs2(:,1),  markers{4}, 'LineWidth',1.2);
loglog(sN, el2_fs3(:,1),  markers{5}, 'LineWidth',1.2);
loglog(sN, el2_vs1(:,1),  markers{6}, 'LineWidth',1.2);
loglog(sN, el2_vs2(:,1),  markers{7}, 'LineWidth',1.2);
loglog(sN, el2_vs3(:,1),  markers{8}, 'LineWidth',1.2);
xlabel(sprintf('N^{1/%d}',dim)); ylabel('Relative L^2 error');
legend('PLS','Diag','FS1','FS2','FS3','VS1','VS2','VS3','Location','best');
title(sprintf('%s: L^2 Error vs N^{1/%d}', testName, dim));
saveas(h, fullfile(results_dir,'error_vs_N.png'));

% 2) Assembly time vs N^{1/d}
h = figure; hold on; grid on;
semilogy(sN, a_time_fs1(:,1), markers{3}, 'LineWidth',1.2);
semilogy(sN, a_time_fs2(:,1), markers{4}, 'LineWidth',1.2);
semilogy(sN, a_time_fs3(:,1), markers{5}, 'LineWidth',1.2);
semilogy(sN, a_time_vs1(:,1), markers{6}, 'LineWidth',1.2);
semilogy(sN, a_time_vs2(:,1), markers{7}, 'LineWidth',1.2);
semilogy(sN, a_time_vs3(:,1), markers{8}, 'LineWidth',1.2);
xlabel(sprintf('N^{1/%d}',dim)); ylabel('Assembly time (s)');
legend('FS1','FS2','FS3','VS1','VS2','VS3','Location','northwest');
title(sprintf('%s: Assembly Time vs N^{1/%d}', testName, dim));
saveas(h, fullfile(results_dir,'assembly_time_vs_N.png'));

% 3) Evaluation time vs N^{1/d}
h = figure; hold on; grid on;
semilogy(sN, e_time_fs1(:,1), markers{3}, 'LineWidth',1.2);
semilogy(sN, e_time_fs2(:,1), markers{4}, 'LineWidth',1.2);
semilogy(sN, e_time_fs3(:,1), markers{5}, 'LineWidth',1.2);
semilogy(sN, e_time_vs1(:,1), markers{6}, 'LineWidth',1.2);
semilogy(sN, e_time_vs2(:,1), markers{7}, 'LineWidth',1.2);
semilogy(sN, e_time_vs3(:,1), markers{8}, 'LineWidth',1.2);
xlabel(sprintf('N^{1/%d}',dim)); ylabel('Evaluation time (s)');
legend('FS1','FS2','FS3','VS1','VS2','VS3','Location','northwest');
title(sprintf('%s: Eval Time vs N^{1/%d}', testName, dim));
saveas(h, fullfile(results_dir,'eval_time_vs_N.png'));

% 4) Error vs Sparsity for each smoothness
strategies = {'fs1','fs2','fs3','vs1','vs2','vs3'};
labels     = {'FS@S1','FS@S2','FS@S3','VS@S1','VS@S2','VS@S3'};
colors     = lines(6);
figure('Position',[100 100 600 800]);
tiledlayout(3,1,'TileSpacing','Compact','Padding','Compact');
for sm = 1:3
    ax = nexttile; hold on; grid on;
    for j = 1:6
        S = eval(sprintf('sparsity_%s(:,%d)',strategies{j},sm));
        E = eval(sprintf('el2_%s(:,%d)',     strategies{j},sm));
        plot(S, E, markers{j}, 'LineWidth',1.2,'Color',colors(j,:));
    end
    yline(mean(el2_poly),'--k','PLS','LineWidth',1);
    title(sprintf('Wendland C^{%d}',2*sm));
    if sm==3, xlabel('Sparsity'); end
    ylabel('Rel L^2 error');
end
legend([labels,'PLS'],'Orientation','horizontal','Location','northoutside');
saveas(gcf, fullfile(results_dir,'error_vs_sparsity.png'));