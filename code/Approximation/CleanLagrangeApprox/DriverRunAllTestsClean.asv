%% Interpolation in 1D/2D/3D domains using CSRBFs combined with
%%Jacobi polynomials. 


%% Spatial dimension
dim = 1;

%% Desired polynomial degrees for each N value
fix_d = 50;
desired_degrees = [fix_d, fix_d, fix_d, fix_d, fix_d, fix_d, fix_d];
% desired_degrees = [1, 2, 3, 4, 5, 6, 7];

%% Load up the node set
if dim==1
    % N = 2.^(2:8); N = N';
    N = 2.^(2:8); N = N';
    for k=1:length(N)
        X = chebspace2(-1,1,N(k));
        xi = X(2:end-1,:);
        xb = [X(1,:); X(end,:)];
        st.fullintnodes{k,1} = xi;
        st.bdrynodes{k,1} = xb;
    end
    % clear N xb xi k;
    clear xb xi k;
    xe = linspace(-1,1,2^14).';
elseif dim==2
    %% Get evaluation nodes
    st = load('DiskPoissonNodesLarge.mat');
    xe =  [st.fullintnodes{7}; st.bdrynodes{7}];

    %st = load('DiskPoissonNodes.mat');
    st = load('DiskPoissonNodesClustered.mat');
    %st = load('StarPoissonNodesClustered.mat');
    %st = load('DomainPoissonNodes2.mat');
%     pxe = haltonset(dim,'Skip',1e3,'Leap',1e2); %Quasi-random node set
%     pxe = scramble(pxe,'RR2');
%     N = (4:5:60).^2; N = N';
%     for k=1:length(N)
%         p = net(pxe,N(k));
%         p = p*2 - 1;
%         st.fullintnodes{k,1} = p;    
%     end
%     xe = net(pxe,10000);
%     xe = xe*2 - 1;
    clear p N pxe;
elseif dim==3
     st = load('SpherePoissonNodesLarge.mat');
     xe = [st.fullintnodes{2}; st.bdrynodes{2}];
% 
     st = load('SpherePoissonNodesClustered.mat');

%    st = load('RBCPoissonNodesClustered.mat');
%    xe = [st.fullintnodes{7}; st.bdrynodes{7}];
%    st = load('BumpySpherePoissonNodes.mat');
%    st = load('BumpySpherePoissonNodesClustered.mat');
%     pxe = haltonset(dim,'Skip',1e3,'Leap',1e2); %Quasi-random node set
%     pxe = scramble(pxe,'RR2');
%     N = (4:5:20).^3; N = N';
%     for k=1:length(N)
%         p = net(pxe,N(k));
%         p = p*2 - 1;
%         st.fullintnodes{k,1} = p;    
%     end
%     xe = net(pxe,10000);
%     xe = xe*2 - 1;
%     clear p N pxe;
end
start_nodes = 1;
end_nodes = size(st.fullintnodes,1);

% Sparsity storage initialization 
sparsity_fs1 = zeros(end_nodes, 3);
sparsity_fs2 = zeros(end_nodes, 3);
sparsity_fs3 = zeros(end_nodes, 3);
sparsity_vs1 = zeros(end_nodes, 3);
sparsity_vs2 = zeros(end_nodes, 3);
sparsity_vs3 = zeros(end_nodes, 3);

% Polynomial degree storage initialization
ell_poly = zeros(end_nodes, 1);          % For pure polynomial interpolation
ell_diag = zeros(end_nodes, 3);         % For diagonal approximation (3 smoothness levels)
ell_fs1 = zeros(end_nodes, 3);          % For fixed support method, K=1e12
ell_fs2 = zeros(end_nodes, 3);          % For fixed support method, K=1e8
ell_fs3 = zeros(end_nodes, 3);          % For fixed support method, K=1e4
ell_vs1 = zeros(end_nodes, 3);          % For variable support method, K=1e12
ell_vs2 = zeros(end_nodes, 3);          % For variable support method, K=1e8
ell_vs3 = zeros(end_nodes, 3);          % For variable support method, K=1e4

% Support and shape parameters initialization
all_eps_fs = zeros(3, 3);  % 3 smoothness levels × 3 K_targets
supports_fs = zeros(3, 3);  
all_eps_vs = zeros(3, 3);   
supports_vs = zeros(3, 3);

%% This partially determines the number of polynomial terms
%slightly smaller fac helps with increasing accuracy for both rough and
%smooth functions. There seems to be a notion of the "best" polynomial
%degree for a given number of nodes
if dim==1
    fac = 1.0;
elseif dim==2
    fac = 0.8; 
elseif dim==3
    fac = 1.0;
end

%% Setup anonymous function for function interpolation true solution
%%We'll use Trefethen's function gallery from his Spectral methods book
%%with 2d and 3d analogues
if dim==1
    syms x;       
    %f = abs(x);                function_name = 'abs_1d';
    %f = exp(-x.^(-2));     function_name = 'exp_1d';
    f = 1./(1 + 25*x.^2);  function_name = 'rk_1d';
    %f = x.^(10);           function_name = 'poly_1d';
    dfx = diff(f,x);
elseif dim==2
    syms x y;    
    f = abs(x).^3 .* abs(y).^3;              function_name = 'abs_2d';
    %f = exp(-x.^(-2)).*exp(-y.^(-2));        function_name = 'exp_2d';
    %f = 1./(1 + 25*(x.^2 + y.^2));           function_name = 'rk_2d';
    %f = exp(-10*((x-.3).^(-2)+y.^(-2)));    function_name = 'exp10_2d';
    %f = exp(-10*((x-.3).^2+y.^2));           function_name = 'exp10inv_2d';
    %f = x.^8 .* y.^8;                        function_name = 'poly_2d';
    dfx = diff(f,x); dfy = diff(f,y);
elseif dim==3
    syms x y z;      
    f = abs(x).^3.*abs(y).^3.*abs(z).^3;              function_name = 'abs_3d';
    %f = exp(-10*((x-.3).^(-2)+y.^(-2) + z.^(-2)));    function_name = 'exp10inv_3d'
    %f = exp(-10*((x-.3).^2+y.^2 + z.^2));             function_name = 'exp10_3d';
    %f = 1./(1 + 25*(x.^2 + y.^2 + z.^2));             function_name = 'rk_3d';
    %f = x.^(4).*y.^(2).*z.^(2);                       function_name = 'poly_3d';
    dfx = diff(f,x); dfy = diff(f,y); dfz = diff(f,z);
end
f = matlabFunction(f);
if dim==1
    dfx = matlabFunction(dfx);
    clear x;
elseif dim==2
    dfx = matlabFunction(dfx);
    dfy = matlabFunction(dfy);
    clear x y;
elseif dim==3
    dfx = matlabFunction(dfx);
    dfy = matlabFunction(dfy);
    dfz = matlabFunction(dfz);
    clear x y z;
end
%% All possible tests:
%% 1. Different smoothness for CSRBF
%% 2. Different shape parameter strats
%% 3. Different interp techniques

%% Get the standard polynomial least squares stuff out of the way
for k=start_nodes:end_nodes
    xi = st.fullintnodes{k};
    xb = st.bdrynodes{k};
    x = [xi;xb];
    alph = 0; %legendre
    % ell = floor(fac*nthroot(length(x),dim));     
    if k <= length(desired_degrees)
        ell = desired_degrees(k);
    else
        ell = floor(fac*nthroot(length(x),dim));
        fprintf('Fallback');
    end
    ell = max([ell,1]); 
    ell_poly(k,1) = ell;
    if dim==1
        y = f(x(:,1));
        ye_true = f(xe(:,1));
    elseif dim==2
        y = f(x(:,1),x(:,2));
        ye_true = f(xe(:,1),xe(:,2));
    elseif dim==3
        y = f(x(:,1),x(:,2),x(:,3));
        ye_true = f(xe(:,1),xe(:,2),xe(:,3));
    end    
    [el2_poly(k,1),elinf_poly(k,1),a_time_poly(k,1),e_time_poly(k,1),c_poly{k,1}] = PLS(x,y,ell,xe,alph,ye_true);   
    sN(k,1) = nthroot(length(x),dim);
end


%% Next, get the diagonal approximation stuff out of the way for different smoothnesses
for smoothness=1:3
    if smoothness==1
        %% Wendland C2 in 3d, pd in all lower dimensions
        rbf = @(e,r) -r.^4.*(4.*r - 5*spones(r));
        drbfor = @(e,r) 20.*e.^2.*r.^3;
        if dim==1
            lrbf = @(e,r) -20.*e.^2.*r.^2.*(2.*r - 3*spones(r));
        elseif dim==2
            lrbf = @(e,r) -20.*e.^2.*r.^2.*(r - 3*spones(r));
        elseif dim==3
            lrbf = @(e,r) 60.*e.^2.*r.^2;
        end
    elseif smoothness==2
        %% Wendland C4 in 3d
        rbf = @(e,r) (r.^6.*(35.*r.^2 - 88.*r + 56*spones(r)))./3;
        drbfor = @(e,r) -(56.*e.^2.*r.^5.*(5.*r - 6*spones(r)))./3;
        if dim==2
            lrbf = @(e,r) (112.*e.^2.*r.^4.*(20.*r.^2 - 36.*r + 15*spones(r)))./3;   
        elseif dim==3    
            lrbf = @(e,r) 56.*e.^2.*r.^4.*(15.*r.^2 - 26.*r + 10*spones(r));
        end
    elseif smoothness==3
        %% Wendland C6 in 3d
        rbf = @(e,r) r.^8.*(66*spones(r) - 154*r + 121*r.^2 - 32*r.^3);
        drbfor = @(e,r) 22.*e.^2.*r.^7.*(16.*r.^2 - 39.*r + 24*spones(r));
        if dim==2
            lrbf = @(e,r) 44*e.^2.*r.^6.*(84*spones(r)-264*r+267*r.^2-88*r.^3);
        elseif dim==3
            lrbf = @(e,r) -66.*e.^2.*r.^6.*((r - spones(r)).^2 - 6.*r + 64.*(r - spones(r)).^3 + 7*spones(r));
        end
    else
        %% Wendland C8 in 3d
        rbf = @(e,r) (6552290047271679.*r.^10.*(4134.*r.^2 - 3536.*r - 2166.*r.^3 + 429.*r.^4 + 1144*spones(r)))./32761450236358396;
        drbfor = @(e,r) -(85179770614531827.*e.^2.*r.^9.*(1056.*r - 852.*r.^2 + 231.*r.^3 - 440*spones(r)))./16380725118179198;
        if dim==2
            lrbf = @(e,r) (85179770614531827.*e.^2.*r.^8.*(11022.*r.^2 - 7700.*r - 6924.*r.^3 + 1617.*r.^4 + 1980*spones(r)))./8190362559089599;
        elseif dim==3
            lrbf = @(e,r) (1277696559217977405.*e.^2.*r.^8.*(1540.*r.^2 - 1056.*r - 980.*r.^3 + 231.*r.^4 + 264*spones(r)))./16380725118179198;
        end
    end

    for k=start_nodes:end_nodes
        xi = st.fullintnodes{k};
        xb = st.bdrynodes{k};
        x = [xi;xb];
        alph = 0; %legendre
        % ell = floor(fac*nthroot(length(x),dim));    
        if k <= length(desired_degrees)
            ell = desired_degrees(k);
        else
            ell = floor(fac*nthroot(length(x),dim));
            fprintf('Fallback');
        end
        ell = max([ell,1]); 
        ell_diag(k,smoothness) = ell;

        if dim==1
            y = f(x(:,1));
            ye_true = f(xe(:,1));
        elseif dim==2
            y = f(x(:,1),x(:,2));
            ye_true = f(xe(:,1),xe(:,2));
        elseif dim==3
            y = f(x(:,1),x(:,2),x(:,3));
            ye_true = f(xe(:,1),xe(:,2),xe(:,3));
        end    
        tree = KDTreeSearcher(x);
        [el2_diag(k,smoothness),elinf_diag(k,smoothness),a_time_diag(k,smoothness),e_time_diag(k,smoothness),c_poly_diag{k,smoothness}] = CSRBFDiag(x,y,ell,xe,alph,rbf,tree,ye_true);    
    end
end

%% Now find shape parameters that induce a target condition number on the finest node set
%% Use those on the coarser node sets, and it looks like the supports are increasing
%% Again, different smoothnesses
for smoothness=1:3
    if smoothness==1
        %% Wendland C2 in 3d, pd in all lower dimensions
        rbf = @(e,r) -r.^4.*(4.*r - 5*spones(r));
        drbfor = @(e,r) 20.*e.^2.*r.^3;
        if dim==1
            lrbf = @(e,r) -20.*e.^2.*r.^2.*(2.*r - 3*spones(r));
        elseif dim==2
            lrbf = @(e,r) -20.*e.^2.*r.^2.*(r - 3*spones(r));
        elseif dim==3
            lrbf = @(e,r) 60.*e.^2.*r.^2;
        end
    elseif smoothness==2
        %% Wendland C4 in 3d
        rbf = @(e,r) (r.^6.*(35.*r.^2 - 88.*r + 56*spones(r)))./3;
        drbfor = @(e,r) -(56.*e.^2.*r.^5.*(5.*r - 6*spones(r)))./3;
        if dim==2
            lrbf = @(e,r) (112.*e.^2.*r.^4.*(20.*r.^2 - 36.*r + 15*spones(r)))./3;   
        elseif dim==3    
            lrbf = @(e,r) 56.*e.^2.*r.^4.*(15.*r.^2 - 26.*r + 10*spones(r));
        end
    elseif smoothness==3
        %% Wendland C6 in 3d
        rbf = @(e,r) r.^8.*(66*spones(r) - 154*r + 121*r.^2 - 32*r.^3);
        drbfor = @(e,r) 22.*e.^2.*r.^7.*(16.*r.^2 - 39.*r + 24*spones(r));
        if dim==2
            lrbf = @(e,r) 44*e.^2.*r.^6.*(84*spones(r)-264*r+267*r.^2-88*r.^3);
        elseif dim==3
            lrbf = @(e,r) -66.*e.^2.*r.^6.*((r - spones(r)).^2 - 6.*r + 64.*(r - spones(r)).^3 + 7*spones(r));
        end
    else
        %% Wendland C8 in 3d
        rbf = @(e,r) (6552290047271679.*r.^10.*(4134.*r.^2 - 3536.*r - 2166.*r.^3 + 429.*r.^4 + 1144*spones(r)))./32761450236358396;
        drbfor = @(e,r) -(85179770614531827.*e.^2.*r.^9.*(1056.*r - 852.*r.^2 + 231.*r.^3 - 440*spones(r)))./16380725118179198;
        if dim==2
            lrbf = @(e,r) (85179770614531827.*e.^2.*r.^8.*(11022.*r.^2 - 7700.*r - 6924.*r.^3 + 1617.*r.^4 + 1980*spones(r)))./8190362559089599;
        elseif dim==3
            lrbf = @(e,r) (1277696559217977405.*e.^2.*r.^8.*(1540.*r.^2 - 1056.*r - 980.*r.^3 + 231.*r.^4 + 264*spones(r)))./16380725118179198;
        end
    end

    %% Three picked condition‐number targets
    K_targets = [1e12, 1e8, 1e4];

    %% Find the epsilons for each K_target on the finest node set
    k_finest = end_nodes;

    xi = st.fullintnodes{k_finest};
    xb = st.bdrynodes{k_finest};
    x_finest = [xi;xb];
    tree_finest = KDTreeSearcher(x_finest);
    [~,dist] = knnsearch(tree_finest,x_finest,'k',2);
    sep_dist = 0.5*min(dist(:,2));
    if dim==1
        sep_dist = 0.5*mean(dist(:,2));
    end

    %% Milena: this works
    % guess an eigenvalue. 3 here is the dim of the Wendland kernel (always 3 in this code)
    % the fourier transform of the Wendland kernel
    % decays at this rate (p), so the eigenvalues must satisfy this on a given
    % point set. This should give us a good guess and possibly a bracket
    p = 2*smoothness + 3 + 1; 
    eps_guess = K_targets.^(-1./p)/sep_dist; 
    eps_fs = zeros(size(eps_guess));  
    options.TolX = 1e-2; %loose tolerance for speed
    for kit=1:3        
        eps0 = eps_guess(kit);
        k_target = K_targets(kit);
        ep_func = @(ep) log10( cond(full(rbf(ep,DistanceMatrixCSRBFwt(x_finest,x_finest,ep,tree_finest))))) - log10(k_target);
        eps_fs(kit) = fzero(ep_func,[eps0*0.01,eps0*10],options); % a bracketed search
        % eps_fs(kit) = fzero(ep_func,[eps0,45*eps0],options); % a bracketed search
    end
    all_eps_fs(smoothness,:) = eps_fs; 
    supports_fs(smoothness,:) = 1./all_eps_fs(smoothness,:);

    for k=start_nodes:end_nodes
        xi = st.fullintnodes{k};
        xb = st.bdrynodes{k};
        x = [xi;xb];
        alph = 0; %legendre
        % ell = floor(fac*nthroot(length(x),dim));
        if k <= length(desired_degrees)
            ell = desired_degrees(k);
        else
            ell = floor(fac*nthroot(length(x),dim));
            fprintf('Fallback');
        end
        ell = max([ell,1]); 
        ell_fs1(k,smoothness) = ell;  % For K=1e12
        ell_fs2(k,smoothness) = ell;  % For K=1e8
        ell_fs3(k,smoothness) = ell;  % For K=1e4
        if dim==1
            y = f(x(:,1));
            ye_true = f(xe(:,1));
        elseif dim==2
            y = f(x(:,1),x(:,2));
            ye_true = f(xe(:,1),xe(:,2));
        elseif dim==3
            y = f(x(:,1),x(:,2),x(:,3));
            ye_true = f(xe(:,1),xe(:,2),xe(:,3));
        end   

        tree = KDTreeSearcher(x);

        % For K_target = 1e12 (j=1)
        ep1 = eps_fs(1);
        [el2_fs1(k,smoothness), elinf_fs1(k,smoothness), a_time_fs1(k,smoothness), e_time_fs1(k,smoothness), c_poly_fs1{k,smoothness}, cond_fs1(k,smoothness), ~, sparsity_fs1(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep1,tree,ye_true);

        % For K_target = 1e8 (j=2)
        ep2 = eps_fs(2);
        [el2_fs2(k,smoothness),elinf_fs2(k,smoothness),a_time_fs2(k,smoothness),e_time_fs2(k,smoothness),c_poly_fs2{k,smoothness}, cond_fs2(k,smoothness), ~, sparsity_fs2(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep2,tree,ye_true); 

        % For K_target = 1e4 (j=3)
        ep3 = eps_fs(3);
        [el2_fs3(k,smoothness),elinf_fs3(k,smoothness),a_time_fs3(k,smoothness),e_time_fs3(k,smoothness),c_poly_fs3{k,smoothness}, cond_fs3(k,smoothness), ~, sparsity_fs3(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep3,tree,ye_true);
    end
end


%% Now do fixed condition number strategies
%% Again, different smoothnesses
K_targets = [1e12, 1e8, 1e4]; 

for smoothness=1:3
    if smoothness==1
        %% Wendland C2 in 3d, pd in all lower dimensions
        rbf = @(e,r) -r.^4.*(4.*r - 5*spones(r));
        drbfor = @(e,r) 20.*e.^2.*r.^3;
        if dim==1
            lrbf = @(e,r) -20.*e.^2.*r.^2.*(2.*r - 3*spones(r));
        elseif dim==2
            lrbf = @(e,r) -20.*e.^2.*r.^2.*(r - 3*spones(r));
        elseif dim==3
            lrbf = @(e,r) 60.*e.^2.*r.^2;
        end
    elseif smoothness==2
        %% Wendland C4 in 3d
        rbf = @(e,r) (r.^6.*(35.*r.^2 - 88.*r + 56*spones(r)))./3;
        drbfor = @(e,r) -(56.*e.^2.*r.^5.*(5.*r - 6*spones(r)))./3;
        if dim==2
            lrbf = @(e,r) (112.*e.^2.*r.^4.*(20.*r.^2 - 36.*r + 15*spones(r)))./3;   
        elseif dim==3    
            lrbf = @(e,r) 56.*e.^2.*r.^4.*(15.*r.^2 - 26.*r + 10*spones(r));
        end
    elseif smoothness==3
        %% Wendland C6 in 3d
        rbf = @(e,r) r.^8.*(66*spones(r) - 154*r + 121*r.^2 - 32*r.^3);
        drbfor = @(e,r) 22.*e.^2.*r.^7.*(16.*r.^2 - 39.*r + 24*spones(r));
        if dim==2
            lrbf = @(e,r) 44*e.^2.*r.^6.*(84*spones(r)-264*r+267*r.^2-88*r.^3);
        elseif dim==3
            lrbf = @(e,r) -66.*e.^2.*r.^6.*((r - spones(r)).^2 - 6.*r + 64.*(r - spones(r)).^3 + 7*spones(r));
        end
    else
        %% Wendland C8 in 3d
        rbf = @(e,r) (6552290047271679.*r.^10.*(4134.*r.^2 - 3536.*r - 2166.*r.^3 + 429.*r.^4 + 1144*spones(r)))./32761450236358396;
        drbfor = @(e,r) -(85179770614531827.*e.^2.*r.^9.*(1056.*r - 852.*r.^2 + 231.*r.^3 - 440*spones(r)))./16380725118179198;
        if dim==2
            lrbf = @(e,r) (85179770614531827.*e.^2.*r.^8.*(11022.*r.^2 - 7700.*r - 6924.*r.^3 + 1617.*r.^4 + 1980*spones(r)))./8190362559089599;
        elseif dim==3
            lrbf = @(e,r) (1277696559217977405.*e.^2.*r.^8.*(1540.*r.^2 - 1056.*r - 980.*r.^3 + 231.*r.^4 + 264*spones(r)))./16380725118179198;
        end
    end

    options.TolX = 1e-4;

    for k=start_nodes:end_nodes
        xi = st.fullintnodes{k};
        xb = st.bdrynodes{k};
        x = [xi;xb];

        Nnodes = size(x,1);

        alph = 0; %legendre
        % ell = floor(fac*nthroot(length(x),dim)); 
        if k <= length(desired_degrees)
            ell = desired_degrees(k);
        else
            ell = floor(fac*nthroot(length(x),dim));
            fprintf('Fallback');
        end
        ell = max([ell,1]);
        ell_vs1(k,smoothness) = ell;  % For K=1e12
        ell_vs2(k,smoothness) = ell;  % For K=1e8
        ell_vs3(k,smoothness) = ell;  % For K=1e4
        if dim==1
            y = f(x(:,1));
            ye_true = f(xe(:,1));
        elseif dim==2
            y = f(x(:,1),x(:,2));
            ye_true = f(xe(:,1),xe(:,2));
        elseif dim==3
            y = f(x(:,1),x(:,2),x(:,3));
            ye_true = f(xe(:,1),xe(:,2),xe(:,3));
        end    
        tree  = KDTreeSearcher(x);    
        [~,dist] = knnsearch(tree,x,'k',2);

        % sep_dist = 0.5*min(dist(:,2));
        % if dim == 1
        %     min_dist = 0.5*min(dist(:,2));
        %     mean_dist = 0.5*mean(dist(:,2));
        % 
        %     % larger min_dist 
        %     sep_dist = max(min_dist, 0.5*mean_dist);
        % 
        %     if min_dist < 1e-10 * mean_dist
        %         sep_dist = 0.5*mean_dist;
        %     end
        % else
        %     % For higher dimensions
        %     sep_dist = 0.5*min(dist(:,2));
        % end

        sep_dist = 0.5*min(dist(:,2));
        if dim==1
            sep_dist = 0.5*mean(dist(:,2));
        end

        
        
        %% Milena: CHECK if this works
        % guess an eigenvalue. 3 here is the dim of the Wendland kernel (always 3 in this code)
        % the fourier transform of the Wendland kernel
        % decays at this rate (p), so the eigenvalues must satisfy this on a given
        % point set. This should give us a good guess and possibly a bracket
        p = 2*smoothness + 3 + 1; 
        eps_guess = K_targets.^(-1./p)/sep_dist; 
        eps_vs = zeros(size(eps_guess));  
        if dim==1
            options.TolX = 1e-6;
        else
            options.TolX = 1e-2; %loose tolerance for speed
        end
        for kit=1:3        
            eps0 = eps_guess(kit);
            k_target = K_targets(kit);
            ep_func = @(ep) log10( cond(full(rbf(ep,DistanceMatrixCSRBFwt(x,x,ep,tree))))) - log10(k_target);
            if dim==1
                eps_vs(kit) = fzero(ep_func,[eps0*0.001,eps0*100],options); % a bracketed search
            else
                eps_vs(kit) = fzero(ep_func,[eps0*0.01,eps0*10],options); % a bracketed search
            end
        end

        all_eps_vs(smoothness,:) = eps_vs; 
        supports_vs(smoothness,:) = 1./all_eps_vs(smoothness,:);
        ep1 = eps_vs(1);
        ep2 = eps_vs(2);
        ep3 = eps_vs(3);

        [el2_vs1(k,smoothness), elinf_vs1(k,smoothness), a_time_vs1(k,smoothness), e_time_vs1(k,smoothness), c_poly_vs1{k,smoothness}, cond_vs1(k,smoothness), ~, sparsity_vs1(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep1,tree,ye_true);
        
        [el2_vs2(k,smoothness), elinf_vs2(k,smoothness), a_time_vs2(k,smoothness),  e_time_vs2(k,smoothness), c_poly_vs2{k,smoothness}, cond_vs2(k,smoothness), ~, sparsity_vs2(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep2,tree,ye_true);
        
        [el2_vs3(k,smoothness), elinf_vs3(k,smoothness), a_time_vs3(k,smoothness), e_time_vs3(k,smoothness), c_poly_vs3{k,smoothness}, cond_vs3(k,smoothness), ~, sparsity_vs3(k,smoothness)] = CSRBFGen(x,y,ell,xe,alph,rbf,ep3,tree,ye_true);
    end
end

%% Save results 
% Timestamp for uniqueness
timestamp = datestr(datetime('now'), 'yyyyMMdd_HHmmss');

% Construct folder and filename
% if fac>=0.5 
%     results_dir = fullfile('code/Approximation/CleanLagrangeApprox/results/', sprintf('%s', function_name),'/high');
% elseif fac<0.5
%     results_dir = fullfile('code/Approximation/CleanLagrangeApprox/results/', sprintf('%s', function_name),'/low');
% elseif fac==1
%     results_dir = fullfile('code/Approximation/CleanLagrangeApprox/results/', sprintf('%s', function_name),'/fixed');
% end
results_dir = fullfile('code/Approximation/CleanLagrangeApprox/results/', sprintf('%s', function_name),'/fixed');
if ~exist(results_dir, 'dir')
    mkdir(results_dir);
end
results_filename = fullfile(results_dir, sprintf('results_%s.mat', function_name));


% Save everything
save(results_filename, ...
    'el2_poly', 'elinf_poly', 'a_time_poly', 'e_time_poly', 'c_poly', 'ell_poly', ...
    'el2_diag', 'elinf_diag', 'a_time_diag', 'e_time_diag', 'c_poly_diag', 'ell_diag', ...
    'el2_fs1', 'elinf_fs1', 'a_time_fs1', 'e_time_fs1', 'c_poly_fs1', 'cond_fs1', 'sparsity_fs1', 'ell_fs1', ...
    'el2_fs2', 'elinf_fs2', 'a_time_fs2', 'e_time_fs2', 'c_poly_fs2', 'cond_fs2', 'sparsity_fs2', 'ell_fs2', ...
    'el2_fs3', 'elinf_fs3', 'a_time_fs3', 'e_time_fs3', 'c_poly_fs3', 'cond_fs3', 'sparsity_fs3', 'ell_fs3', ...
    'all_eps_fs', 'supports_fs', ...
    'el2_vs1', 'elinf_vs1', 'a_time_vs1', 'e_time_vs1', 'c_poly_vs1', 'cond_vs1', 'sparsity_vs1', 'ell_vs1', ...
    'el2_vs2', 'elinf_vs2', 'a_time_vs2', 'e_time_vs2', 'c_poly_vs2', 'cond_vs2', 'sparsity_vs2', 'ell_vs2', ...
    'el2_vs3', 'elinf_vs3', 'a_time_vs3', 'e_time_vs3', 'c_poly_vs3', 'cond_vs3', 'sparsity_vs3', 'ell_vs3', ...
    'all_eps_vs', 'supports_vs', ...
    'sN', 'dim', 'function_name', 'timestamp');